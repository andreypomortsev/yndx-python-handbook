## [Хвост](../../../solutions/3.5/35_j.py)

В семействе операционных систем Linux существует одна прекрасная консольная утилита — `tail`. Она предназначена для случаев, когда нам не нужно читать весь файл, а достаточно просмотреть только несколько последних строк.

Напишите аналог этой утилиты.

### Формат ввода

Пользователь вводит имя файла ($F$), а затем количество строк ($N$), которые он хочет увидеть.

### Формат вывода:

Выведите $N$ последних строк файла $F$.

### Пример

__Ввод__
```plaintext
# Пользовательский ввод:
some_file.txt
2

# Содержимое файла some_file.txt
1 строка
2 строка
3 строка
4 строка
5 строка
```

__Вывод__
```plaintext
4 строка
5 строка
```

## Подход к решению

### Открытие файла и перемещение указателя

   - Файл открывается в бинарном режиме (`rb`), чтобы работать с байтами. Это позволяет считывать файл построчно независимо от его кодировки.
   - С помощью [`file.seek(0, 2)`](https://docs.python.org/3/library/io.html#io.IOBase.seek) указатель перемещается в конец файла.  
   - Используем `tell()` так как этот метод возвращает размер файла в байтах, что позволяет корректно управлять перемещением указателя.

### Чтение файла с конца

   - Используется буфер [`buffer`](https://docs.python.org/3.1/library/functions.html#bytearray), чтобы постепенно собирать строки в бинарном виде с конца файла.
   - Цикл повторяется до тех пор, пока:
     1. Указатель не дойдёт до начала файла `pointer_location > 0`.
     2. Не будет собрано достаточно строк (строки проверяются через длину массива `lines`).
   - В каждой итерации:
        - Размер блока для чтения — это либо оставшиеся байты до начала файла, либо `SIZE` (32 байта).
        - Указатель перемещается на `chunk_size` байт назад: `file.seek(pointer_location - chunk_size)` в направлении к началу файла.
        - Считывается кусок данных: `file.read(chunk_size)`.
        - Новый блок данных добавляется к началу буфера: `buffer = chunk + buffer`, важно отметить, что именно в таком виде, а не `buffer += chunk`.
        - Содержимое буфера разделяется по символу переноса строки `\n`: `lines = buffer.split(b"\n")`.

### Проверка количества строк

   - Счётчик строк обновляется при каждой итерации: `read_lines = len(lines)`.
   - Если количество строк (`read_lines`) становится больше или равно `tail + 1`, чтение прекращается. Это позволяет избежать лишнего чтения файла.

### Вывод последних строк

   - Из массива `lines` выбираются последние `tail` строк: `lines[-tail:]`, так как при чтении блоками мы можем прочитать кусок "лишней" строки.
   - Каждая строка декодируется из байт в строку с указанной кодировкой (`DEFAULT_ENCODING`) и выводится.
