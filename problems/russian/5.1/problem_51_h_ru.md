## [Шашки](../../../solutions/5.1/51_h.py)

Шашки очень занимательная игра, которую достаточно легко моделировать.

Правила подразумевают наличие двух классов: игральная доска и шашка. Однако мы немного упростим себе задачу и вместо шашки будем манипулировать клетками, которые могут находиться в трех состояниях: пустая, белая шашка и чёрная шашка.

Разработайте два класса: `Checkers` и `Cell`.

Объекты класса `Checkers` при инициализации строят игральную доску со стандартным распределением клеток и должны обладать методами:

- `move(f, t)` — перемещает шашку из позиции `f` в позицию `t`;
- `get_cell(p)` — возвращает объект «клетка» в позиции `p`.

Объекты класса `Cell` при инициализации принимают одно из трех состояний:
- __W__ — белая шашка,
- __B__ — чёрная шашка,
- __X__ — пустая клетка,

а также обладают методом `status()` возвращающим заложенное в ней состояние.

Координаты клеток описываются строками вида PQ, где:

- P — столбец игральной доски, одна из заглавных латинских букв: ABCDEFGH;
- Q — строка игральной доски, одна из цифр: 12345678.

Будем считать, что пользователь всегда ходит правильно и контролировать возможность хода не требуется.

### Примечание

Ваше решение должно содержать только классы и функции.\
В решении не должно быть вызовов инициализации требуемых классов.

### Пример 1

__Ввод__
```python
checkers = Checkers()
for row in '87654321':
    for col in 'ABCDEFGH':
        print(checkers.get_cell(col + row).status(), end='')
    print()
```

__Вывод__
```plaintext
XBXBXBXB
BXBXBXBX
XBXBXBXB
XXXXXXXX
XXXXXXXX
WXWXWXWX
XWXWXWXW
WXWXWXWX
```

### Пример 2

__Ввод__
```python
checkers = Checkers()
checkers.move('C3', 'D4')
checkers.move('H6', 'G5')
for row in '87654321':
    for col in 'ABCDEFGH':
        print(checkers.get_cell(col + row).status(), end='')
    print()
```

__Вывод__
```plaintext
XBXBXBXB
BXBXBXBX
XBXBXBXX
XXXXXXBX
XXXWXXXX
WXXXWXWX
XWXWXWXW
WXWXWXWX
```