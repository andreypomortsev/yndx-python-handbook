## [Отчёт успеваемости](../../../solutions/6.2/62_f.py)

Во всех без исключения учебных заведениях ведутся журналы успеваемости. Это отличный пример данных, подлежащих обработке.

Рассмотрим журнал летней олимпиадной школы, в которой основными предметами выступают математика, физика и информатика. Данные об успеваемости представлены _DataFrame_ со столбцами:

- `name` — имя;
- `maths` — оценка по математике;
- `physics` — оценка по физике;
- `computer science` — оценка по информатике.

Напишите функцию `best`, которая фильтрует всех «ударников» в журнале.

### Примечание

Ваше решение должно содержать только функции.\
В решении не должно быть вызовов требуемых функций.

### Пример

**Ввод**
```python
columns = ['name', 'maths', 'physics', 'computer science']
data = {
    'name': ['Иванов', 'Петров', 'Сидоров', 'Васечкин', 'Николаев'],
    'maths': [5, 4, 5, 2, 4],
    'physics': [4, 4, 4, 5, 5],
    'computer science': [5, 2, 5, 4, 3]
}
journal = pd.DataFrame(data, columns=columns)
filtered = best(journal)
print(journal)
print(filtered)
```

**Вывод**
```plaintext
       name  maths  physics  computer science
0    Иванов      5        4                 5
1    Петров      4        4                 2
2   Сидоров      5        4                 5
3  Васечкин      2        5                 4
4  Николаев      4        5                 3
      name  maths  physics  computer science
0   Иванов      5        4                 5
2  Сидоров      5        4                 5
```

## Подход к решению

Для фильтрации _DataFrame_ с учётом условия, что все оценки ученика (ряды) должны быть больше 3, мы используем булевые маски.

### Шаги решения

__1. Исключение столбца с именами для сравнения__

   Поскольку нам нужно сравнивать только числовые данные (оценки), убираем столбец `name` с помощью `pd.DataFrame.iloc[:, 1:]`. Это оставляет только оценки:

   ```plaintext
      maths  physics  computer science
   0      5        4                 5
   1      4        4                 2
   2      5        4                 5
   3      2        5                 4
   4      4        5                 3
   ```

__2. Создание булевой маски на основе условия__

   Сравниваем все элементы с числом 3 с помощью `(journal.iloc[:, 1:] > 3)`. Это создаёт маску, где каждое значение указывает, выполняется ли условие для соответствующей оценки:

   ```plaintext
      maths  physics  computer science
   0   True     True              True
   1   True     True             False
   2   True     True              True
   3  False     True              True
   4   True     True             False
   ```

__3. Определение строк, удовлетворяющих условию__

   Чтобы оставить только те строки, где все значения `True`, используем метод `.all(axis=1)`.  
   Параметр `axis=1` указывает, что проверка должна выполняться по строкам (для каждого ученика). Результатом будет серия булевых значений, указывающих, какие строки следует оставить:

   ```plaintext
   0     True
   1    False
   2     True
   3    False
   4    False
   dtype: bool
   ```

   Если убрать параметр `axis=1` (по умолчанию `axis=0`), проверка будет выполнена по столбцам, и результат станет:

   ```plaintext
   maths               False
   physics              True
   computer science    False
   dtype: bool
   ```

   Такой результат не подходит для нашей задачи.

__4. Фильтрация данных с помощью маски__

   Применяем полученную булевую маску к исходному _DataFrame_, чтобы оставить только строки, соответствующие условию:

   ```python
   journal[(journal.iloc[:, 1:] > 3).all(axis=1)]
   ```

### Конечный результат
Для приведённого примера данные фильтруются следующим образом:

__Исходный DataFrame:__

```plaintext
       name  maths  physics  computer science
0    Иванов      5        4                 5
1    Петров      4        4                 2
2   Сидоров      5        4                 5
3  Васечкин      2        5                 4
4  Николаев      4        5                 3
```

__Фильтрованный DataFrame:__

```plaintext
      name  maths  physics  computer science
0   Иванов      5        4                 5
2  Сидоров      5        4                 5
```